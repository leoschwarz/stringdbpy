---
title: Comparing GSEA results for multiple contrasts
date: today
format:
  html:
    code-fold: false
jupyter: python3
params:
  data_file: null    # or "~"
---



```{python}
#| include: false
#| tags: [parameters]

# declare the parameter (default None)
data_file: str | None = None
```

```{python}
#| vscode: {languageId: python}
#| include: false
import polars as pl
import pandas as pd
import numpy as np
from math import pi, cos, sin
import plotly.graph_objects as go
from pathlib import Path

from string_gsea.network import summarize_terms, separate_pivot_longer
from string_gsea.network import make_network
from string_gsea.network import make_network_with_colors, plot_network_graph
from string_gsea.network import interactive_cytoscape, plot_network_graph_plotly, add_gene_ratio
from string_gsea.cluster_genesets import make_nested_dict, convert_to_binary, plot_term_distance_heatmap
from string_gsea.gsea_plotting import make_upset, plot_term_ridges
import warnings
warnings.filterwarnings(
    "ignore",
    message="A value is trying to be set on a copy of a DataFrame or Series through chained assignment",
    category=FutureWarning,
)
```

```{python}
#| vscode: {languageId: python}
#| include: false
wd = %pwd
print(Path(wd))
```


```{python}
#| vscode: {languageId: python}
#| include: false
# Define input directory and file

if data_file is None:
    # fallback, or raise, or skip
    file = Path(wd).parent/"tests/data/dummy_out/WU_abcd_GSEA/from_rnk"/"WUabcd_string_gsea_results_long.xlsx"
else:
    file = Path(data_file)

print("Using file:", file)

# Read Excel and convert to Polars
# Read Excel file directly with polars
df = pl.read_excel(file)
# Select and explode protein columns
```


```{python}
#| vscode: {languageId: python}
#| include: false
df = add_gene_ratio(df)
xd = separate_pivot_longer(df)
xd = summarize_terms(xd)
```


```{python}
#| vscode: {languageId: python}
#| echo: false
#| output: asis
#| include: true
#| warning: false


display(Markdown(f"::: {{.panel-tabset}}\n"))
for cat in category_list:
    # each of these becomes a tab
    display(Markdown(f"## Cat.: {cat}\n"))

    xdf = xd.filter(
        (pl.col("contrast") == cont) & (pl.col("category") == cat)
    )
    if xdf.is_empty():
        display(Markdown("_No data for this category_"))
    else:
        TermNetworkPlotter.plot_network(xd, category=cat, contrast=cont, thresh=1)
        
        display(Markdown("\n"))
        display(Markdown(TermNetworkPlotter.TermNetworkPlotter.get_figure_legend()))
        display(Markdown("\n"))

        #G = make_network_with_colors(xdf)
        #fig = plot_network_graph_plotly(G, f"{cont} – {cat}")
        #fig.update_layout(width=800, height=800)
        #fig.show()
        #display(Markdown("""\nNetwork plot using bipartite hybrid layout.
        #The proteins are the nodes, and the terms are the nodes.
        #The edges are the interactions between proteins and terms.
        #The color of the protein nodes represents the protein input value (log2FC, t-statistic, etc.). 
        #The color of the term nodes represents the mean of the protein input values of the proteins in the term.
        #The border of the term nodes represents the direction of enrichment (blue - bottom, yellow - top, green - both ends).\n
        #"""))
        one_nested = nested[cont][cat]
        g = plot_term_distance_heatmap(one_nested)
        plt.setp(g.ax_heatmap.yaxis.get_majorticklabels(), rotation=0)
        plt.show()
        display(Markdown("""\nHeatmap showing term and protein distances, using Jaccard index.
        Each row represents a protein, and each column represents a term.
        The color of the cell represents the protein input value (log2FC, t-statistic, etc.).\n"""))
        binary = convert_to_binary(one_nested, to_boolean=True)
        upset = make_upset(binary, xdf)
        axes = upset.plot()
        plt.show()
        display(Markdown(f"\n\n"))
        display(Markdown("""Upset plot showing the overlap of terms and proteins.
        On the left you see the term size (number of proteins matching the term).
        On the top you see the number of proteins unique to a term, or a combination of terms."""))
        display(Markdown(f"\n\n"))
        g = plot_term_ridges(xdf)
        plt.show(g.figure)
        display(Markdown("""\nRidgeline plot showing the distribution of protein input values (log2FC, t-statistic, etc.) for each term.
        The border color of the ridges corresponds to the direction of enrichment,
        and the height of the bar at the right of each ridge corresponds to the -log10(FDR) (higher is better).
        The color of the density plot is proportional to the gene ratio (number of proteins matching the term divided by the total number of proteins in the term).\n"""))
display(Markdown(f":::\n"))
```
# upset 

```{python}
#| echo: false
from string_gsea.gsea_plotting import make_upset_contrasts_terms

# 1) Grab just the term–contrast pairs (ensure uniqueness)

make_upset_contrasts_terms(xd, category="SMART")
```


# plotting comparison of enrichment results for  terms

```{python}
xd_smart = xd.drop([col for col in xd.columns if col.startswith("protein")]).unique()
xd_smart = xd_smart.filter(pl.col("category") == "SMART")

from string_gsea.dotplot_endrichment import dotplot_enrichment
dotplot_enrichment(xd_smart)

```


# Network for several contrasts.



```{python}
#| vscode: {languageId: python}
#| include: true
#| echo: false
from matplotlib import pyplot as plt
from string_gsea import TermNetworkPlotter
TermNetworkPlotter.plot_network(xd, category="SMART", thresh=1)

```

```{python}
#| vscode: {languageId: python}
#| include: true
#| echo: false
TermNetworkPlotter.plot_network(xd, category="SMART", thresh=4, use_fixed_layout=False)
# graph for single contrast
```

```{python}
#| echo: false
# crurious to see if the code above works for single contrast
# filter for a single contrast
TermNetworkPlotter.plot_network(xd, category="SMART", contrast=xd.get_column("contrast").unique()[0], thresh=1)

```


